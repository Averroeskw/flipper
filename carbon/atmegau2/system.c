#define __private_include__
#include <flipper/carbon.h>
#include <flipper/atmegau2/megausb.h>

/* The fmr_device object containing global state about this device. */
struct _lf_device lf_self = {
	{
		"flipper",
		0xc713,
		LF_VERSION,
		(lf_device_16bit | lf_device_little_endian)
	},
	&megausb,
	E_OK
};

#define cpu_prescale(clock) (CLKPR = 0x80, CLKPR = clock)

void system_task(void) {
	while (1) {
		struct _fmr_packet packet;
		int8_t _e = megausb_pull(&megausb, (void *)(&packet), sizeof(struct _fmr_packet));
		if (!(_e < lf_success)) {
			/* Create a buffer to the result of the operation. */
			struct _fmr_result result;
			/* Execute the packet. */
			fmr_perform(&packet, &result);
			/* Send the result back to the host. */
			megausb_push(&megausb, &result, sizeof(struct _fmr_result));
			/* Clear any error state generated by the procedure. */
			lf_error_clear();
		}
		/* Pet the watchdog. */
		wdt_reset();
	}
}

void os_task_init() {
	system_task();
}

fmr_return fmr_push(struct _fmr_push_pull_packet *packet) {
	fmr_return retval = 0xdeadbeef;
	void *swap = malloc(packet -> length);
	if (!swap) {
		lf_error_raise(E_MALLOC, NULL);
		return -1;
	}
	lf_self.endpoint -> pull(lf_self.endpoint, swap, packet -> length);
	*(uintptr_t *)(packet -> call.parameters) = (uintptr_t)swap;
	retval = fmr_execute(packet -> call.index, packet -> call.function, packet -> call.argc, packet -> call.types, (void *)(packet -> call.parameters));
	free(swap);
	return retval;
}

fmr_return fmr_pull(struct _fmr_push_pull_packet *packet) {
	fmr_return retval = 0xdeadbeef;
	void *swap = malloc(packet -> length);
	if (!swap) {
		lf_error_raise(E_MALLOC, NULL);
		return -1;
	}
	*(uintptr_t *)(packet -> call.parameters) = (uintptr_t)swap;
	retval = fmr_execute(packet -> call.index, packet -> call.function, packet -> call.argc, packet -> call.types, (void *)(packet -> call.parameters));
	lf_self.endpoint -> push(lf_self.endpoint, swap, packet -> length);
	free(swap);
	return retval;
}

void system_init() {
	/* Prescale CPU for maximum clock. */
	cpu_prescale(0);
	/* Configure the USB subsystem. */
	configure_usb();
	/* Configure the UART0 subsystem. */
	uart0_configure();
	/* Enable the watchdog timer. */
	wdt_enable(WDTO_500MS);
	/* Configure reset button and PCINT8 interrupt. */
//	PCMSK1 |= (1 << PCINT8);
//	PCICR |= (1 << PCIE1);

	/* Turn the SAM4S on. */
	set_bit_in_port(SAM_POWER_PIN, SAM_POWER_PORT);
	/* Configure the SAM4S's power pin as an output. */
	set_bit_in_port(SAM_POWER_PIN, SAM_POWER_DDR);
	/* Deassert the SAM4S's test pin. */
	clear_bit_in_port(SAM_TEST_PIN, SAM_TEST_PORT);
	/* Configure the SAM4S's test pin as an output. */
	set_bit_in_port(SAM_TEST_PIN, SAM_TEST_DDR);
	/* Dessert the SAM4S's reset pin. */
	set_bit_in_port(SAM_RESET_PIN, SAM_RESET_PORT);
	/* Configure the SAM4S's reset pin as an output. */
	set_bit_in_port(SAM_RESET_PIN, SAM_RESET_DDR);
	/* Deassert the erase pin. */
	clear_bit_in_port(SAM_ERASE_PIN, SAM_ERASE_PORT);
	/* Configure the SAM4S's erase pin as an output. */
	set_bit_in_port(SAM_ERASE_PIN, SAM_ERASE_DDR);


	/* Globally enable interrupts. */
	sei();
}

void system_deinit(void) {
	/* Clear the state of the status LED. */
	led_rgb(LED_OFF);
}

void system_reset(void) {
	/* Shutdown the system. */
	system_deinit();
	/* Fire the watchdog timer. */
	wdt_fire();
	/* Wait until reset. */
	while (1);
}

/* PCINT8 interrupt service routine; captures reset button press and resets the device. */
ISR (PCINT1_vect) {
	system_reset();
}
